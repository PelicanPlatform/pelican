package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

func main() {
	Config()
}

var requiredKeys = [4]string{"name", "description", "default", "type"}

func Config() {
	filename, _ := filepath.Abs("../docs/parameters.yaml")
	yamlFile, err := os.Open(filename)

	if err != nil {
		panic(err)
	}

	decoder := yaml.NewDecoder(yamlFile)

	var values []interface{}

	for {
		var value map[string]interface{}
		if err := decoder.Decode(&value); err != nil {
			if err == io.EOF {
				break
			}
			panic(fmt.Errorf("document decode failed: %w", err))
		}
		values = append(values, value)
	}

	configMap := make(map[string]string)

	configEntry := values[0].(map[string]interface{})
	configBase := configEntry["default"].(string)

	firstEntry := values[1].(map[string]interface{})
	firstEnumKey := firstEntry["name"].(string)
	firstEnumBase := strings.SplitAfterN(firstEntry["default"].(string), "/", 2)[1]

	for i := 1; i < len(values)-1; i++ {
		entry := values[i].(map[string]interface{})
		for j := 0; j < len(requiredKeys); j++ {
			_, ok := entry[requiredKeys[j]]
			if !ok {
				errMsg := "all entries require the " + requiredKeys[j] + " field to populated"
				panic(errMsg)
			}

			if i != 1 {
				name := entry["name"].(string)
				fPath := strings.SplitAfterN(entry["default"].(string), "/", 2)[1]
				configMap[name] = fPath
			}
		}
	}

	f, err := os.Create("parameters.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = packageTemplate.Execute(f, struct {
		FirstKey   string
		FirstRoot  string
		ConfigBase string
		Params     map[string]string
	}{FirstKey: firstEnumKey, FirstRoot: firstEnumBase, ConfigBase: configBase, Params: configMap})

	if err != nil {
		panic(err)
	}
}

// As more varied paramters get added to parameters.yaml with different paths and names, this may need to be
// altered to be more general
var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.

package config

import (
	"path/filepath"
	"github.com/spf13/viper"
)

var rootBase string = "/etc/pelican"
var configBase string

type Param int64

var isRoot bool

const (
	{{.FirstKey}} Param = iota{{range $key, $value := .Params }}
	{{$key}}
	{{- end }}
)

func SetRoot(root bool) {
	isRoot = root
}

func SetConfigBase(cBase string){
	configBase = cBase
}

func (p Param) path() string {
	switch p {
	case {{.FirstKey}}:
		return {{printf "%q" .FirstRoot}}{{range $key, $value := .Params }}
	case {{$key}}:
		return {{printf "%q" $value}}{{end}}
	}
	return "unknown"
}

func (p Param) name() string {
	switch p {
	case {{.FirstKey}}:
		return {{printf "%q" .FirstKey}}{{range $key, $value := .Params}}
	case {{$key}}:
		return {{printf "%q" $key}}{{end}}
	}
	return "unknown"
}

func (p Param) SetPath() {
	relPath := p.path()
	if isRoot {
		viper.SetDefault(p.name(), filepath.Join(rootBase, relPath))
	} else {
		viper.SetDefault(p.name(), filepath.Join(configBase, relPath))
	}
}

func (p Param) GetPath() string {
	enumName := p.name()

	return viper.GetString(enumName)
}
`))
