package main

// This should not be included in any release of pelican, instead only the generated "parameters.go" should packaged

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v2"
)

func main() {
	GenParamEnum()
}

var requiredKeys = [4]string{"name", "description", "default", "type"}

func GenParamEnum() {
	/*
	* This generated a file "config/parameters.go" that is based off of docs/parameters.yaml to be used
	* instead of explicit calls to viper.Get*
	 */
	filename, _ := filepath.Abs("../docs/parameters.yaml")
	yamlFile, err := os.Open(filename)

	if err != nil {
		panic(err)
	}

	// This decoder and for loop is needed because the yaml file has multiple '---' delineated docs
	decoder := yaml.NewDecoder(yamlFile)

	var values []interface{}

	for {
		var value map[string]interface{}
		if err := decoder.Decode(&value); err != nil {
			if err == io.EOF {
				break
			}
			panic(fmt.Errorf("document decode failed: %w", err))
		}
		values = append(values, value)
	}

	configMap := make(map[string]string)

	// Skip the first parameter (ConfigBase is special)
	// Save the first parameter seperately in order to do "<pname> Param = iota" for the enums
	firstEntry := values[1].(map[string]interface{})
	firstEnumKey := firstEntry["name"].(string)
	firstEnumBase := strings.SplitAfterN(firstEntry["default"].(string), "/", 2)[1]

	// Parse and check the values of each parameter against the required Keys
	for i := 1; i < len(values)-1; i++ {
		entry := values[i].(map[string]interface{})
		for j := 0; j < len(requiredKeys); j++ {
			_, ok := entry[requiredKeys[j]]
			if !ok {
				errMsg := "all entries require the " + requiredKeys[j] + " field to populated"
				panic(errMsg)
			}

			if i != 1 {
				name := entry["name"].(string)
				fPath := strings.SplitAfterN(entry["default"].(string), "/", 2)[1]
				configMap[name] = fPath
			}
		}
	}

	// Create the file to be generated
	f, err := os.Create("parameters.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	// Generate the code based on the template
	err = packageTemplate.Execute(f, struct {
		FirstKey  string
		FirstRoot string
		Params    map[string]string
	}{FirstKey: firstEnumKey, FirstRoot: firstEnumBase, Params: configMap})

	if err != nil {
		panic(err)
	}
}

// As more varied paramters get added to parameters.yaml with different paths and names, this may need to be
// altered to be more general
var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.

package config

import (
	"path/filepath"
	"github.com/spf13/viper"
)

var rootBase string = "/etc/pelican"
var configBase string

type Param int64

var isRoot bool

const (
	{{.FirstKey}} Param = iota{{range $key, $value := .Params }}
	{{$key}}
	{{- end }}
)

func SetRoot(root bool) {
	isRoot = root
}

func SetConfigBase(cBase string){
	configBase = cBase
}

func (p Param) path() string {
	switch p {
	case {{.FirstKey}}:
		return {{printf "%q" .FirstRoot}}{{range $key, $value := .Params }}
	case {{$key}}:
		return {{printf "%q" $value}}{{end}}
	}
	return "unknown"
}

func (p Param) name() string {
	switch p {
	case {{.FirstKey}}:
		return {{printf "%q" .FirstKey}}{{range $key, $value := .Params}}
	case {{$key}}:
		return {{printf "%q" $key}}{{end}}
	}
	return "unknown"
}

func (p Param) SetPath() {
	relPath := p.path()
	if isRoot {
		viper.SetDefault(p.name(), filepath.Join(rootBase, relPath))
	} else {
		viper.SetDefault(p.name(), filepath.Join(configBase, relPath))
	}
}

func (p Param) GetPath() string {
	enumName := p.name()

	return viper.GetString(enumName)
}
`))
