/***************************************************************
*
* Copyright (C) 2025, Pelican Project, Morgridge Institute for Research
*
* Licensed under the Apache License, Version 2.0 (the "License"); you
* may not use this file except in compliance with the License.  You may
* obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
***************************************************************/

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"gopkg.in/yaml.v3"
)

type FeatureVersion struct {
	FeatureVersion   string `yaml:"FeatureVersion"`
	NotBeforePelican string `yaml:"NotBeforePelican"`
	NotAfterPelican  string `yaml:"NotAfterPelican"`
}

type Feature struct {
	Name     string           `yaml:"Name"`
	Origin   []FeatureVersion `yaml:"Origin"`
	Cache    []FeatureVersion `yaml:"Cache"`
	Director []FeatureVersion `yaml:"Director"`
	Registry []FeatureVersion `yaml:"Registry"`
}

func GenServerFeatures() {
	filename, _ := filepath.Abs("../features/resources/feature-version-compatibility.yaml")
	yamlFile, err := os.Open(filename)
	if err != nil {
		panic(err)
	}
	defer yamlFile.Close()

	decoder := yaml.NewDecoder(yamlFile)

	var feature Feature
	if err := decoder.Decode(&feature); err != nil {
		panic(fmt.Errorf("document decode failed: %w", err))
	}

	// Create the file to be generated
	f, err := os.Create("../features/features.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = featuresTemplate.Execute(f, struct {
		Feature Feature
	}{
		Feature: feature,
	})

	if err != nil {
		panic(err)
	}
}

var featuresTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT THIS FILE.
// To make changes to source, see generate/server_features_generator.go and features/resources/feature-version-compatibility.yaml
/***************************************************************
*
* Copyright (C) 2025, Pelican Project, Morgridge Institute for Research
*
* Licensed under the Apache License, Version 2.0 (the "License"); you
* may not use this file except in compliance with the License.  You may
* obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
***************************************************************/

package features

import (
	"github.com/pkg/errors"
	"fmt"
)

// Feature represents a server feature with its versions.
type Feature struct {
	Name     string
	Origin   map[string]FeatureVersionInfo
	Cache    map[string]FeatureVersionInfo
	Director map[string]FeatureVersionInfo
	Registry map[string]FeatureVersionInfo
}

// VersionInfo holds the version compatibility details for a feature.
type FeatureVersionInfo struct {
	FeatureVersion   string
	NotBeforePelican string
	NotAfterPelican  string
}

// GetName returns the name of the feature.
func (f Feature) GetName() string {
	return f.Name
}

// GetOriginMin returns the NotBeforePelican version for a given feature version in Origin.
func (f Feature) GetOriginMin(version string) (string, error) {
	if v, ok := f.Origin[version]; ok {
		return v.NotBeforePelican, nil
	}
	return "", errors.Errorf("version '%s' not found for feature '%s' in Origin", version, f.Name)
}

// GetOriginMax returns the NotAfterPelican version for a given feature version in Origin.
func (f Feature) GetOriginMax(version string) (string, error) {
	if v, ok := f.Origin[version]; ok {
		return v.NotAfterPelican, nil
	}
	return "", errors.Errorf("version '%s' not found for feature '%s' in Origin", version, f.Name)
}

// GetCacheMin returns the NotBeforePelican version for a given feature version in Cache.
func (f Feature) GetCacheMin(version string) (string, error) {
	if v, ok := f.Cache[version]; ok {
		return v.NotBeforePelican, nil
	}
	return "", errors.Errorf("version '%s' not found for feature '%s' in Cache", version, f.Name)
}

// GetCacheMax returns the NotAfterPelican version for a given feature version in Cache.
func (f Feature) GetCacheMax(version string) (string, error) {
	if v, ok := f.Cache[version]; ok {
		return v.NotAfterPelican, nil
	}
	return "", errors.Errorf("version '%s' not found for feature '%s' in Cache", version, f.Name)
}

// featuresMap maps feature names to their corresponding Feature structs.
var featuresMap = map[string]Feature{
	"{{.Feature.Name}}": {{.Feature.Name}},
}

// GetFeature retrieves a feature by its name.
func GetFeature(name string) (Feature, error) {
	if feature, ok := featuresMap[name]; ok {
		return feature, nil
	}
	return Feature{}, fmt.Errorf("feature '%s' not found", name)
}

var {{.Feature.Name}} = Feature{
	Name: "{{.Feature.Name}}",
	Origin: map[string]FeatureVersionInfo{
		{{- range $version := .Feature.Origin }}
		"{{$version.FeatureVersion}}": {
			NotBeforePelican: "{{$version.NotBeforePelican}}",
			NotAfterPelican:  "{{$version.NotAfterPelican}}",
		},
		{{- end }}
	},
	Cache: map[string]FeatureVersionInfo{
		{{- range $version := .Feature.Cache }}
		"{{$version.FeatureVersion}}": {
			NotBeforePelican: "{{$version.NotBeforePelican}}",
			NotAfterPelican:  "{{$version.NotAfterPelican}}",
		},
		{{- end }}
	},
}
`))
