/***************************************************************
 *
 * Copyright (C) 2024, Pelican Project, Morgridge Institute for Research
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ***************************************************************/

package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type ErrorType struct {
	Raw       string // Raw is the raw error type specified with a '.' separator
	Display   string // Display is the error type used in the function headers with a '_' separator
	ExitCode  int
	Code      int
	Retryable bool
}

var requiredErrorKeys = [4]string{"code", "clientExitCode", "description", "retryable"}

// GenErrorCodes takes the error_codes.yaml file (located: ../docs/error_codes.yaml) and generates the error_codes/error_codes.go file
func GenErrorCodes() {
	filename, _ := filepath.Abs("../docs/error_codes.yaml")
	yamlFile, err := os.Open(filename)
	if err != nil {
		panic(err)
	}
	defer yamlFile.Close()

	decoder := yaml.NewDecoder(yamlFile)

	var values []interface{}

	for {
		var value map[string]interface{}
		if err := decoder.Decode(&value); err != nil {
			if err == io.EOF {
				break
			}
			panic(fmt.Errorf("%v: document decode failed", err))
		}
		values = append(values, value)
	}

	errors := make([]ErrorType, 0)

	// Loop through the values from the error_codes.yaml, here we check that the required keys
	// are present and append them to the ErrorType object
	for i, value := range values {
		entry := value.(map[string]interface{})

		// Ensure we have the 'type' attribute for the error and that it is a trying
		errorType, exists := entry["type"].(string)
		if !exists {
			panic(fmt.Sprintf("Error: listed entry number %d from yaml is missing the 'type' attribute (or it is not a string): Current values are: %v", i, value))
		}
		// Check we have all the required keys
		for _, keyName := range requiredErrorKeys {
			if _, exists := entry[keyName]; !exists {
				panic(fmt.Sprintf("Parameter entry '%s' is missing required key '%s'", errorType, keyName))
			}
		}
		// Covert all errors to camel then snake case
		camelErrorName := handleCaseConversion(errorType)
		errorNameInSnake := strings.ReplaceAll(camelErrorName, ".", "_")
		displayName := errorNameInSnake

		// Extract all the other values
		// Note: the value should not be missing since we already checked, therefore any errors are thrown if types are incorrect
		exitCode, ok := entry["clientExitCode"].(int)
		if !ok {
			panic(fmt.Sprintf("Error: listed entry number %d from yaml, 'exit code' attribute is not an int: Current values are: %v", i, value))
		}

		code, ok := entry["code"].(int)
		if !ok {
			panic(fmt.Sprintf("Error: listed entry number %d from yaml, 'code' attribute is not an int: Current values are: %v", i, value))
		}

		retryable, ok := entry["retryable"].(bool)
		if !ok {
			panic(fmt.Sprintf("Error: listed entry number %d from yaml, 'retryable' attribute is not a boolean: Current values are: %v", i, value))
		}

		errors = append(errors, ErrorType{Raw: camelErrorName, Display: displayName, ExitCode: exitCode,
			Code: code, Retryable: retryable})
	}

	// Create the file to be generated
	f, err := os.Create("../error_codes/error_codes.go")
	if err != nil {
		panic(fmt.Sprintf("%v: failed to create error_codes.go", err))
	}
	defer f.Close()

	err = errorTemplate.Execute(f, struct {
		PelicanErrors []ErrorType
	}{
		PelicanErrors: errors,
	})

	if err != nil {
		panic(fmt.Sprintf("%v: failed to execute template for error_codes.go", err))
	}
}

var errorTemplate = template.Must(template.New("").Parse(`// Code generated by go generate at this location: /generate/error_code_generator.go; DO NOT EDIT.
/***************************************************************
 *
 * Copyright (C) 2024, Pelican Project, Morgridge Institute for Research
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ***************************************************************/

package error_codes

import (
	"fmt"
)

type PelicanError struct {
	errorType string
	exitCode  int
	code      int
	retryable bool
	err       error
}
{{range $idx, $pelicanError := .PelicanErrors}}
func New{{$pelicanError.Display}}Error(err error) *PelicanError {
	return &PelicanError{
		errorType: "{{$pelicanError.Raw}}",
		exitCode:  {{$pelicanError.ExitCode}},
		code:      {{$pelicanError.Code}},
		retryable: {{$pelicanError.Retryable}},
		err:       err,
	}
}
{{end}}
// function that maps the error to the exit code
func (e *PelicanError) ExitCode() int {
	return e.exitCode
}

// function that takes in a PelicanError object and returns it in a string formatted message
func (e *PelicanError) Error() string {
	if e.err != nil {
		return fmt.Sprintf("%s Error: Error code %d: %v", e.errorType, e.code, e.err)
	}
	return e.errorType
}

// This function takes in a PelicanError unwraps any inner errors wrapped inside of it
func (e *PelicanError) Unwrap() error {
	return e.err
}

// This function takes in an existing error and wraps it into a PelicanError object
func (e *PelicanError) Wrap(err error) *PelicanError {
	e.err = err
	return e
}
`))
