// Code generated by go generate at this location: /generate/error_code_generator.go; DO NOT EDIT.
/***************************************************************
 *
 * Copyright (C) 2025, Pelican Project, Morgridge Institute for Research
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License.  You may
 * obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ***************************************************************/

package error_codes

import (
	"fmt"
)

type PelicanError struct {
	errorType   string
	exitCode    int
	code        int
	retryable   bool
	description string
	err         error
}

func NewParameterError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Parameter",
		exitCode:    4,
		code:        1000,
		retryable:   false,
		description: "If the client failed to start, or was started with invalid parameters, or otherwise believes what it was asked to do is impossible or the request itself is malformed.",
		err:         err,
	}
}

func NewParameter_FileNotFoundError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Parameter.FileNotFound",
		exitCode:    4,
		code:        1011,
		retryable:   false,
		description: "If the client was started with a file that does not exist.",
		err:         err,
	}
}

func NewResolutionError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Resolution",
		exitCode:    5,
		code:        2000,
		retryable:   false,
		description: "Indicates that the client failed to even attempt to contact the server.",
		err:         err,
	}
}

func NewContactError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Contact",
		exitCode:    6,
		code:        3000,
		retryable:   false,
		description: "The client attempted to contact the server at its resolved address and failed to do so.",
		err:         err,
	}
}

func NewContact_DirectorError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Contact.Director",
		exitCode:    6,
		code:        3001,
		retryable:   false,
		description: "The client attempted to contact the director at its found address but failed to do so.",
		err:         err,
	}
}

func NewContact_CacheError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Contact.Cache",
		exitCode:    11,
		code:        3002,
		retryable:   true,
		description: "The client attempted to contact the cache but failed to do so.",
		err:         err,
	}
}

func NewContact_OriginError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Contact.Origin",
		exitCode:    6,
		code:        3003,
		retryable:   false,
		description: "The client attempted to contact the origin but failed to do so.",
		err:         err,
	}
}

func NewContact_RegistryError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Contact.Registry",
		exitCode:    6,
		code:        3004,
		retryable:   false,
		description: "The client attempted to contact the registry (usually through the director) but failed to do so.",
		err:         err,
	}
}

func NewAuthorizationError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Authorization",
		exitCode:    7,
		code:        4000,
		retryable:   false,
		description: "The client contacted the server but failed to authenticate, or failed to authorize, or if the server replied with an authorization error when the file was requested or sent.",
		err:         err,
	}
}

func NewSpecificationError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Specification",
		exitCode:    8,
		code:        5000,
		retryable:   false,
		description: "If the client successfully contacted the server and received a definitive response that the desired file was not present or could not be created. Usually the submitters fault.",
		err:         err,
	}
}

func NewSpecification_FileNotFoundError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Specification.FileNotFound",
		exitCode:    8,
		code:        5011,
		retryable:   false,
		description: "If the client successfully contacted the server but the desired file does not exist for download. The user might have entered the wrong URL or the file might not yet be at the specified origin.",
		err:         err,
	}
}

func NewSpecification_FileNotCreatedError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Specification.FileNotCreated",
		exitCode:    8,
		code:        5002,
		retryable:   false,
		description: "If the client successfully contacted the server but the desired file for upload could not be created.",
		err:         err,
	}
}

func NewTransferError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Transfer",
		exitCode:    9,
		code:        6000,
		retryable:   true,
		description: "The client started transferring the file but did not complete it for some reason, or if the file failed post-transfer validation.",
		err:         err,
	}
}

func NewTransfer_StoppedTransferError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Transfer.StoppedTransfer",
		exitCode:    11,
		code:        6001,
		retryable:   true,
		description: "The client started transferring file(s) but it got cancelled by Pelican as stopped transferring data.",
		err:         err,
	}
}

func NewTransfer_SlowTransferError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Transfer.SlowTransfer",
		exitCode:    11,
		code:        6002,
		retryable:   true,
		description: "The client started transferring data but the transfer was slower than the minimum configured timeout rate.",
		err:         err,
	}
}

func NewTransfer_TimedOutError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Transfer.TimedOut",
		exitCode:    11,
		code:        6003,
		retryable:   true,
		description: "The client started transferring data but the transfer timed out.",
		err:         err,
	}
}

func NewTransfer_HeaderTimeoutError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Transfer.HeaderTimeout",
		exitCode:    11,
		code:        6004,
		retryable:   true,
		description: "The client attempted to contact the server but timed out waiting for response headers. This indicates the server did not respond before the header timeout threshold.",
		err:         err,
	}
}

func NewTransfer_DirectorTimeoutError(err error) *PelicanError {
	return &PelicanError{
		errorType:   "Transfer.DirectorTimeout",
		exitCode:    11,
		code:        6005,
		retryable:   true,
		description: "The client timed out while querying the director for namespace information. This indicates the director did not respond before the timeout threshold.",
		err:         err,
	}
}

// function that maps the error to the exit code
func (e *PelicanError) ExitCode() int {
	return e.exitCode
}

// function that takes in a PelicanError object and returns it in a string formatted message
func (e *PelicanError) Error() string {
	if e.err != nil {
		return fmt.Sprintf("%s Error: Error code %d: %v", e.errorType, e.code, e.err)
	}
	return e.errorType
}

// This function takes in a PelicanError unwraps any inner errors wrapped inside of it
func (e *PelicanError) Unwrap() error {
	return e.err
}

// This function takes in an existing error and wraps it into a PelicanError object
func (e *PelicanError) Wrap(err error) *PelicanError {
	e.err = err
	return e
}

// Code returns the Pelican error code
func (e *PelicanError) Code() int {
	return e.code
}

// IsRetryable returns whether the error is retryable
func (e *PelicanError) IsRetryable() bool {
	return e.retryable
}

// ErrorType returns the error type string
func (e *PelicanError) ErrorType() string {
	return e.errorType
}

// Description returns the human-readable error description
func (e *PelicanError) Description() string {
	return e.description
}
